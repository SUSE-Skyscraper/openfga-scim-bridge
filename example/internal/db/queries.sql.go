// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createGroup = `-- name: CreateGroup :one
insert into groups (display_name, created_at, updated_at)
values ($1, now(), now())
returning id, display_name, created_at, updated_at
`

func (q *Queries) CreateGroup(ctx context.Context, displayName string) (Group, error) {
	row := q.db.QueryRow(ctx, createGroup, displayName)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMembershipForUserAndGroup = `-- name: CreateMembershipForUserAndGroup :exec
insert into group_users (user_id, group_id)
values ($1, $2)
on conflict (user_id, group_id) do nothing
`

type CreateMembershipForUserAndGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) CreateMembershipForUserAndGroup(ctx context.Context, arg CreateMembershipForUserAndGroupParams) error {
	_, err := q.db.Exec(ctx, createMembershipForUserAndGroup, arg.UserID, arg.GroupID)
	return err
}

const createUser = `-- name: CreateUser :one
insert into users (username, name, display_name, emails, active, locale, external_id, created_at, updated_at)
values ($1, $2, $3, $4, $5, $6, $7, now(), now())
returning id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
`

type CreateUserParams struct {
	Username    string
	Name        pgtype.JSONB
	DisplayName sql.NullString
	Emails      pgtype.JSONB
	Active      bool
	Locale      sql.NullString
	ExternalID  sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Name,
		arg.DisplayName,
		arg.Emails,
		arg.Active,
		arg.Locale,
		arg.ExternalID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Locale,
		&i.Active,
		&i.Emails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
delete
from api_keys
where id = $1
`

func (q *Queries) DeleteAPIKey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAPIKey, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
delete
from groups
where id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGroup, id)
	return err
}

const deleteScimAPIKey = `-- name: DeleteScimAPIKey :exec
delete
from scim_api_keys
where domain = 'default'
`

func (q *Queries) DeleteScimAPIKey(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteScimAPIKey)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
delete
from users
where id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const dropMembershipForGroup = `-- name: DropMembershipForGroup :exec
delete
from group_users
where group_id = $1
`

func (q *Queries) DropMembershipForGroup(ctx context.Context, groupID uuid.UUID) error {
	_, err := q.db.Exec(ctx, dropMembershipForGroup, groupID)
	return err
}

const dropMembershipForUserAndGroup = `-- name: DropMembershipForUserAndGroup :exec
delete
from group_users
where user_id = $1
  and group_id = $2
`

type DropMembershipForUserAndGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) DropMembershipForUserAndGroup(ctx context.Context, arg DropMembershipForUserAndGroupParams) error {
	_, err := q.db.Exec(ctx, dropMembershipForUserAndGroup, arg.UserID, arg.GroupID)
	return err
}

const findAPIKey = `-- name: FindAPIKey :one
select id, encodedhash, owner, description, system, created_at, updated_at
from api_keys
where id = $1
  and system = false
`

func (q *Queries) FindAPIKey(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, findAPIKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Encodedhash,
		&i.Owner,
		&i.Description,
		&i.System,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAPIKeysById = `-- name: FindAPIKeysById :many
select id, encodedhash, owner, description, system, created_at, updated_at
from api_keys
where id = ANY ($1::uuid[])
`

func (q *Queries) FindAPIKeysById(ctx context.Context, dollar_1 []uuid.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, findAPIKeysById, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.Encodedhash,
			&i.Owner,
			&i.Description,
			&i.System,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByUsername = `-- name: FindByUsername :one
select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
where username = $1
`

func (q *Queries) FindByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, findByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Locale,
		&i.Active,
		&i.Emails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findScimAPIKey = `-- name: FindScimAPIKey :one
select api_keys.id, api_keys.encodedhash, api_keys.owner, api_keys.description, api_keys.system, api_keys.created_at, api_keys.updated_at
from api_keys
         left join scim_api_keys on scim_api_keys.api_key_id = api_keys.id
where scim_api_keys.domain = 'default'
  and api_keys.system = true
`

func (q *Queries) FindScimAPIKey(ctx context.Context) (ApiKey, error) {
	row := q.db.QueryRow(ctx, findScimAPIKey)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Encodedhash,
		&i.Owner,
		&i.Description,
		&i.System,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPIKeys = `-- name: GetAPIKeys :many
select id, encodedhash, owner, description, system, created_at, updated_at
from api_keys
where system = false
`

func (q *Queries) GetAPIKeys(ctx context.Context) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, getAPIKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.Encodedhash,
			&i.Owner,
			&i.Description,
			&i.System,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroup = `-- name: GetGroup :one
select id, display_name, created_at, updated_at
from groups
where id = $1
`

func (q *Queries) GetGroup(ctx context.Context, id uuid.UUID) (Group, error) {
	row := q.db.QueryRow(ctx, getGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupCount = `-- name: GetGroupCount :one
select count(*)
from groups
`

func (q *Queries) GetGroupCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getGroupCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGroupMembership = `-- name: GetGroupMembership :many

select group_users.group_id, group_users.user_id, users.username as username
from group_users
         left join users on users.id = group_users.user_id
where group_users.group_id = $1
`

type GetGroupMembershipRow struct {
	GroupID  uuid.UUID
	UserID   uuid.UUID
	Username sql.NullString
}

// ------------------------------------------------------------------------------------------------------------------
// Membership
// ------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetGroupMembership(ctx context.Context, groupID uuid.UUID) ([]GetGroupMembershipRow, error) {
	rows, err := q.db.Query(ctx, getGroupMembership, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupMembershipRow
	for rows.Next() {
		var i GetGroupMembershipRow
		if err := rows.Scan(&i.GroupID, &i.UserID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembershipForUser = `-- name: GetGroupMembershipForUser :one
select group_users.group_id, group_users.user_id, users.username as username
from group_users
         left join users on users.id = group_users.user_id
where group_users.group_id = $1
  and group_users.user_id = $2
`

type GetGroupMembershipForUserParams struct {
	GroupID uuid.UUID
	UserID  uuid.UUID
}

type GetGroupMembershipForUserRow struct {
	GroupID  uuid.UUID
	UserID   uuid.UUID
	Username sql.NullString
}

func (q *Queries) GetGroupMembershipForUser(ctx context.Context, arg GetGroupMembershipForUserParams) (GetGroupMembershipForUserRow, error) {
	row := q.db.QueryRow(ctx, getGroupMembershipForUser, arg.GroupID, arg.UserID)
	var i GetGroupMembershipForUserRow
	err := row.Scan(&i.GroupID, &i.UserID, &i.Username)
	return i, err
}

const getGroups = `-- name: GetGroups :many

select id, display_name, created_at, updated_at
from groups
order by id
LIMIT $1 OFFSET $2
`

type GetGroupsParams struct {
	Limit  int32
	Offset int32
}

// ------------------------------------------------------------------------------------------------------------------
// Groups
// ------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetGroups(ctx context.Context, arg GetGroupsParams) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
where id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Locale,
		&i.Active,
		&i.Emails,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserCount = `-- name: GetUserCount :one
select count(*)
from users
`

func (q *Queries) GetUserCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getUserCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUsers = `-- name: GetUsers :many

select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
order by created_at
LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit  int32
	Offset int32
}

// ------------------------------------------------------------------------------------------------------------------
// Users
// ------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ExternalID,
			&i.Name,
			&i.DisplayName,
			&i.Locale,
			&i.Active,
			&i.Emails,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersById = `-- name: GetUsersById :many
select id, username, external_id, name, display_name, locale, active, emails, created_at, updated_at
from users
where id = ANY ($1::uuid[])
order by display_name
`

func (q *Queries) GetUsersById(ctx context.Context, dollar_1 []uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersById, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.ExternalID,
			&i.Name,
			&i.DisplayName,
			&i.Locale,
			&i.Active,
			&i.Emails,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAPIKey = `-- name: InsertAPIKey :one

insert into api_keys (encodedhash, system, owner, description, created_at, updated_at)
values ($1, $2, $3, $4, now(), now())
returning id, encodedhash, owner, description, system, created_at, updated_at
`

type InsertAPIKeyParams struct {
	Encodedhash string
	System      bool
	Owner       string
	Description sql.NullString
}

// ------------------------------------------------------------------------------------------------------------------
// SCIM API Key
// ------------------------------------------------------------------------------------------------------------------
func (q *Queries) InsertAPIKey(ctx context.Context, arg InsertAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, insertAPIKey,
		arg.Encodedhash,
		arg.System,
		arg.Owner,
		arg.Description,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Encodedhash,
		&i.Owner,
		&i.Description,
		&i.System,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertScimAPIKey = `-- name: InsertScimAPIKey :one
insert into scim_api_keys (api_key_id, domain, created_at, updated_at)
values ($1, 'default', now(), now())
returning id, domain, api_key_id, created_at, updated_at
`

func (q *Queries) InsertScimAPIKey(ctx context.Context, apiKeyID uuid.UUID) (ScimApiKey, error) {
	row := q.db.QueryRow(ctx, insertScimAPIKey, apiKeyID)
	var i ScimApiKey
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.ApiKeyID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const patchGroupDisplayName = `-- name: PatchGroupDisplayName :exec
update groups
set display_name = $2,
    updated_at   = now()
where id = $1
`

type PatchGroupDisplayNameParams struct {
	ID          uuid.UUID
	DisplayName string
}

func (q *Queries) PatchGroupDisplayName(ctx context.Context, arg PatchGroupDisplayNameParams) error {
	_, err := q.db.Exec(ctx, patchGroupDisplayName, arg.ID, arg.DisplayName)
	return err
}

const patchUser = `-- name: PatchUser :exec
update users
set active     = $2,
    updated_at = now()
where id = $1
`

type PatchUserParams struct {
	ID     uuid.UUID
	Active bool
}

func (q *Queries) PatchUser(ctx context.Context, arg PatchUserParams) error {
	_, err := q.db.Exec(ctx, patchUser, arg.ID, arg.Active)
	return err
}

const updateUser = `-- name: UpdateUser :exec
update users
set username     =$2,
    name         = $3,
    display_name = $4,
    emails       = $5,
    active       = $6,
    external_id  = $7,
    locale       = $8,
    updated_at   = now()
where id = $1
`

type UpdateUserParams struct {
	ID          uuid.UUID
	Username    string
	Name        pgtype.JSONB
	DisplayName sql.NullString
	Emails      pgtype.JSONB
	Active      bool
	ExternalID  sql.NullString
	Locale      sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Name,
		arg.DisplayName,
		arg.Emails,
		arg.Active,
		arg.ExternalID,
		arg.Locale,
	)
	return err
}
